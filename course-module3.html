<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flutter Interview Course - Module 3: State Management</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');

    :root {
      --primary: #00FFA3;
      --primary-dark: #00140f;
      --accent: #00c67f;
      --bg: #010807;
      --card: rgba(2, 10, 8, 0.95);
      --border: rgba(0, 255, 163, 0.28);
      --text: #E8FFF5;
      --text-dim: #9ed7be;
      --shadow: 0 30px 90px rgba(0, 0, 0, 0.65);
      --code-bg: #031611;
      --code-border: rgba(0, 255, 163, 0.25);
      --brand-gradient: linear-gradient(135deg, #00FFA3 0%, #000000 100%);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      line-height: 1.8;
      background: radial-gradient(circle at 10% 20%, rgba(0, 255, 163, 0.2), transparent 45%),
            radial-gradient(circle at 80% 80%, rgba(0, 255, 163, 0.12), transparent 50%),
            linear-gradient(135deg, #000000, #020d08 55%, #000000 100%);
      color: var(--text);
      min-height: 100vh;
      padding: 40px 20px 60px;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 50% 0%, rgba(0, 255, 163, 0.12), transparent 60%);
      opacity: 0.5;
      pointer-events: none;
    }

    .container {
      max-width: 1150px;
      margin: 0 auto;
      background: var(--card);
      border-radius: 30px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: var(--shadow);
      overflow: hidden;
      position: relative;
    }

    .course-header {
      background: var(--brand-gradient);
      color: var(--text);
      padding: 70px 40px 60px;
      text-align: center;
      position: relative;
    }

    .course-header::after {
      content: '';
      position: absolute;
      inset: 18px;
      border-radius: 28px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      opacity: 0.7;
    }

    .course-header h1 {
      font-size: clamp(2.4rem, 5vw, 3.6rem);
      margin-bottom: 12px;
      position: relative;
      z-index: 1;
    }

    .course-header p {
      font-size: 1.3rem;
      color: rgba(255, 255, 255, 0.85);
      position: relative;
      z-index: 1;
    }

    .module-badge {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 14px 32px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(0, 0, 0, 0.25);
      font-weight: 700;
      letter-spacing: 0.12em;
      margin-top: 22px;
      position: relative;
      z-index: 1;
    }

    .content { padding: 52px 60px; }

    .lesson-divider {
      background: linear-gradient(120deg, rgba(0, 255, 163, 0.25), rgba(0, 0, 0, 0.85));
      color: var(--text);
      padding: 30px;
      border-radius: 22px;
      margin: 55px 0 40px;
      text-align: center;
      border: 1px solid var(--border);
      box-shadow: 0 25px 55px rgba(0, 0, 0, 0.55);
      position: relative;
      overflow: hidden;
    }

    .lesson-divider::after {
      content: '';
      position: absolute;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      width: 40%;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent);
    }

    .lesson-divider h2 {
      border: none;
      margin: 0;
      font-size: clamp(2rem, 4vw, 2.4rem);
    }

    .analogy-box,
    .tip-box,
    .warning-box,
    .interview-section {
      border-radius: 20px;
      padding: 26px;
      margin: 28px 0;
      border: 1px solid var(--border);
      background: linear-gradient(140deg, rgba(0, 0, 0, 0.85), rgba(0, 255, 163, 0.08));
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.45);
    }

    .analogy-box {
      display: flex;
      gap: 22px;
      align-items: flex-start;
      border-left: 6px solid #FDD835;
    }

    .analogy-emoji { font-size: 3.2rem; }

    h2 {
      color: var(--text);
      font-size: 2.1rem;
      margin-top: 40px;
      border-left: 6px solid var(--primary);
      padding-left: 18px;
    }

    h3 { color: var(--primary); font-size: 1.7rem; margin-top: 32px; }
    h4 {
      color: var(--text-dim);
      font-size: 1.35rem;
      margin-top: 24px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    p, li {
      font-size: 1.05rem;
      margin: 14px 0;
      color: var(--text-dim);
    }

    ul, ol { margin: 20px 0; padding-left: 32px; }
    li { margin: 10px 0; }

    .tip-box { border-left: 6px solid var(--primary); }
    .warning-box { border-left: 6px solid #ff8a65; }

    pre {
      background: var(--code-bg);
      color: var(--text);
      padding: 26px;
      border-radius: 18px;
      border: 1px solid var(--code-border);
      margin: 26px 0;
      overflow-x: auto;
      font-family: 'JetBrains Mono', 'Courier New', monospace;
      font-size: 0.96rem;
      line-height: 1.7;
      box-shadow: inset 0 0 30px rgba(0, 255, 163, 0.08);
    }

    code { font-family: inherit; }

    .code-inline {
      background: rgba(0, 255, 163, 0.1);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 2px 8px;
      color: var(--primary);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 32px 0;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
    }

    th {
      background: var(--brand-gradient);
      color: var(--text);
      padding: 18px;
      text-align: left;
      letter-spacing: 0.08em;
    }

    td {
      padding: 18px 22px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.35);
      color: var(--text-dim);
    }

    tr:nth-child(even) td { background: rgba(0, 255, 163, 0.04); }
    tr:hover td { background: rgba(0, 255, 163, 0.08); transition: background 0.3s ease; }

    .interview-section {
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 255, 163, 0.08));
      border-left: 6px solid #ab47bc;
    }

    .interview-section h3 { color: var(--text); font-size: 1.9rem; }

    .interview-qa {
      margin: 22px 0;
      background: rgba(0, 0, 0, 0.5);
      padding: 22px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .question { color: var(--primary); font-weight: 700; margin-bottom: 10px; }
    .answer { color: var(--text-dim); }

    .navigation-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      margin: 55px 0 40px;
    }

    .nav-button {
      flex: 1 1 240px;
      padding: 18px 30px;
      border-radius: 16px;
      text-decoration: none;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: var(--brand-gradient);
      box-shadow: 0 22px 50px rgba(0, 0, 0, 0.55);
      transition: transform 0.3s, box-shadow 0.3s;
    }

    .nav-button.prev { background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 255, 163, 0.28)); }
    .nav-button.next { background: linear-gradient(135deg, rgba(0, 255, 163, 0.28), rgba(0, 0, 0, 0.85)); }

    .nav-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 35px 70px rgba(0, 0, 0, 0.65);
    }

    footer {
      background: rgba(0, 0, 0, 0.7);
      color: var(--text-dim);
      text-align: center;
      padding: 32px;
      font-size: 1rem;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    footer strong { color: var(--primary); }

    @media (max-width: 900px) {
      .content { padding: 40px 25px; }
      .analogy-box { flex-direction: column; text-align: center; }
    }

    @media (max-width: 600px) {
      body { padding: 20px 12px 40px; }
      .navigation-buttons { flex-direction: column; }
    }

    @media print {
      body { background: #fff; color: #111; padding: 0; }
      .container { border: none; box-shadow: none; }
      .course-header,
      .lesson-divider,
      .analogy-box,
      .tip-box,
      .warning-box,
      .interview-section,
      table,
      .nav-button {
        background: #fff;
        color: #000;
        border: 1px solid #ccc;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>
    <div class="container">
        <div class="course-header">
            <h1>‚ö° Module 3: State Management</h1>
            <p>Master the art of managing app state from simple to complex patterns</p>
            <div class="module-badge">Module 3 of 8</div>
        </div>
        
        <div class="content">
            
            <!-- ========================================== -->
            <!-- LESSON 3.1: BASIC STATE MANAGEMENT -->
            <!-- ========================================== -->
            
            <div class="lesson-divider">
                <h2>üìä Lesson 3.1: Basic State Management with setState()</h2>
            </div>
            
            <div class="analogy-box">
                <div class="analogy-emoji">üìù</div>
                <div>
                    <h3>Explain Like You're 5: Classroom Whiteboard</h3>
                    <p>
                        Imagine a teacher writing on a whiteboard! When the teacher erases and writes new information, 
                        everyone in the class sees the update instantly. <strong>setState()</strong> is like erasing 
                        and rewriting - it tells Flutter "Hey, something changed, redraw the screen!" The whiteboard 
                        is your widget, and calling setState() tells Flutter to "refresh" it so everyone sees the 
                        latest information.
                    </p>
                </div>
            </div>
            
            <h3>üéØ What is State?</h3>
            
            <p>
                <strong>State</strong> is data that can change over time. When state changes, the UI needs to rebuild 
                to reflect those changes. Examples: counter value, selected tab, checkbox status, form inputs.
            </p>
            
            <h4>1Ô∏è‚É£ StatefulWidget Anatomy</h4>
            
            <pre><code class="language-dart">// The widget class (immutable)
class CounterWidget extends StatefulWidget {
  const CounterWidget({Key? key}) : super(key: key);
  
  @override
  State&lt;CounterWidget&gt; createState() => _CounterWidgetState();
}

// The state class (mutable - holds changing data)
class _CounterWidgetState extends State&lt;CounterWidget&gt; {
  int _counter = 0; // State variable (private, can change)
  
  void _incrementCounter() {
    setState(() {
      _counter++; // Modify state inside setState()
    });
    // After setState(), Flutter rebuilds the widget tree
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text('You clicked $_counter times', style: TextStyle(fontSize: 24)),
        SizedBox(height: 20),
        ElevatedButton(
          onPressed: _incrementCounter,
          child: Text('Click Me!'),
        ),
      ],
    );
  }
}</code></pre>
            
            <h4>2Ô∏è‚É£ StatefulWidget Lifecycle</h4>
            
            <p>
                Understanding the lifecycle is crucial for interviews and debugging!
            </p>
            
            <pre><code class="language-dart">class LifecycleDemo extends StatefulWidget {
  @override
  State&lt;LifecycleDemo&gt; createState() => _LifecycleDemoState();
}

class _LifecycleDemoState extends State&lt;LifecycleDemo&gt; {
  
  // 1Ô∏è‚É£ Called when state object is created (once)
  @override
  void initState() {
    super.initState();
    print('initState: Initialize data, start timers, API calls');
    // Perfect for: Setting initial values, starting listeners
  }
  
  // 2Ô∏è‚É£ Called when widget configuration changes (rare)
  @override
  void didUpdateWidget(covariant LifecycleDemo oldWidget) {
    super.didUpdateWidget(oldWidget);
    print('didUpdateWidget: Parent rebuilt with new config');
  }
  
  // 3Ô∏è‚É£ Called every time the widget rebuilds
  @override
  Widget build(BuildContext context) {
    print('build: Rebuilding widget tree');
    return Container();
  }
  
  // 4Ô∏è‚É£ Called when widget is removed permanently
  @override
  void dispose() {
    print('dispose: Clean up controllers, listeners, timers');
    super.dispose();
    // CRITICAL: Cancel subscriptions, dispose controllers to prevent memory leaks!
  }
}</code></pre>
            
            <table>
                <thead>
                    <tr>
                        <th>Lifecycle Method</th>
                        <th>When Called</th>
                        <th>Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>initState()</strong></td>
                        <td>Once, when State object created</td>
                        <td>Initialize data, start API calls, create controllers</td>
                    </tr>
                    <tr>
                        <td><strong>build()</strong></td>
                        <td>Every time setState() is called</td>
                        <td>Return the widget tree (UI)</td>
                    </tr>
                    <tr>
                        <td><strong>didUpdateWidget()</strong></td>
                        <td>When parent rebuilds with new config</td>
                        <td>Compare old and new widget properties</td>
                    </tr>
                    <tr>
                        <td><strong>setState()</strong></td>
                        <td>When you want to update UI</td>
                        <td>Modify state variables and trigger rebuild</td>
                    </tr>
                    <tr>
                        <td><strong>dispose()</strong></td>
                        <td>When widget permanently removed</td>
                        <td>Clean up: dispose controllers, cancel timers, close streams</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="warning-box">
                <h4>‚ö†Ô∏è Common setState() Mistakes</h4>
                <pre><code class="language-dart">// ‚ùå WRONG: Modifying state without setState
void _increment() {
  _counter++; // UI won't update!
}

// ‚úÖ CORRECT: Always use setState
void _increment() {
  setState(() {
    _counter++; // UI updates immediately
  });
}

// ‚ùå WRONG: Heavy operations inside setState
setState(() {
  _data = heavyComputation(); // Blocks UI thread!
});

// ‚úÖ CORRECT: Compute first, then setState
final result = heavyComputation();
setState(() {
  _data = result; // Only update state
});</code></pre>
            </div>
            
            
            <!-- ========================================== -->
            <!-- LESSON 3.2: INHERITEDWIDGET PATTERN -->
            <!-- ========================================== -->
            
            <div class="lesson-divider">
                <h2>üéÇ Lesson 3.2: InheritedWidget & InheritedModel</h2>
            </div>
            
            <div class="analogy-box">
                <div class="analogy-emoji">üç™</div>
                <div>
                    <h3>Explain Like You're 5: Cookie Basket</h3>
                    <p>
                        Imagine a big basket of cookies in the kitchen that everyone in the house can access! 
                        <strong>InheritedWidget</strong> is like that cookie basket - it sits high up in the widget 
                        tree (kitchen), and any child widget below it (family members) can reach up and grab data 
                        (cookies) without needing to pass them hand-to-hand. When the basket changes (mom refills it), 
                        everyone who was watching it gets notified!
                    </p>
                </div>
            </div>
            
            <h3>üéØ Why InheritedWidget?</h3>
            
            <p>
                Passing data through multiple widget layers using constructors is tedious. InheritedWidget allows 
                any descendant widget to access shared data without prop drilling.
            </p>
            
            <h4>1Ô∏è‚É£ Creating an InheritedWidget</h4>
            
            <pre><code class="language-dart">// Define the InheritedWidget
class UserData extends InheritedWidget {
  final String userName;
  final int userAge;
  
  const UserData({
    Key? key,
    required this.userName,
    required this.userAge,
    required Widget child,
  }) : super(key: key, child: child);
  
  // Provide static method to access data from anywhere below
  static UserData? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType&lt;UserData&gt;();
  }
  
  // Return true to rebuild dependent widgets when data changes
  @override
  bool updateShouldNotify(UserData oldWidget) {
    return userName != oldWidget.userName || userAge != oldWidget.userAge;
  }
}

// Usage: Wrap your widget tree
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return UserData(
      userName: 'John Doe',
      userAge: 25,
      child: MaterialApp(
        home: HomePage(), // HomePage and all children can access UserData
      ),
    );
  }
}

// Access data from any descendant widget
class ProfileWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final userData = UserData.of(context)!; // Access inherited data
    
    return Column(
      children: [
        Text('Name: ${userData.userName}'),
        Text('Age: ${userData.userAge}'),
      ],
    );
  }
}</code></pre>
            
            <h4>2Ô∏è‚É£ InheritedModel - Optimized Updates</h4>
            
            <p>
                InheritedModel allows fine-grained updates - only rebuild widgets that depend on specific aspects 
                of data.
            </p>
            
            <pre><code class="language-dart">// Define aspects (what can change)
enum UserAspect { name, age, email }

class UserModel extends InheritedModel&lt;UserAspect&gt; {
  final String name;
  final int age;
  final String email;
  
  const UserModel({
    Key? key,
    required this.name,
    required this.age,
    required this.email,
    required Widget child,
  }) : super(key: key, child: child);
  
  static UserModel? of(BuildContext context, {UserAspect? aspect}) {
    return InheritedModel.inheritFrom&lt;UserModel&gt;(context, aspect: aspect);
  }
  
  @override
  bool updateShouldNotify(UserModel oldWidget) {
    return name != oldWidget.name || age != oldWidget.age || email != oldWidget.email;
  }
  
  @override
  bool updateShouldNotifyDependent(UserModel oldWidget, Set&lt;UserAspect&gt; dependencies) {
    if (dependencies.contains(UserAspect.name) && name != oldWidget.name) return true;
    if (dependencies.contains(UserAspect.age) && age != oldWidget.age) return true;
    if (dependencies.contains(UserAspect.email) && email != oldWidget.email) return true;
    return false;
  }
}

// Widget that only rebuilds when name changes
class NameDisplay extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final user = UserModel.of(context, aspect: UserAspect.name)!;
    return Text('Name: ${user.name}');
    // Only rebuilds when name changes, not age or email!
  }
}</code></pre>
            
            <div class="tip-box">
                <h4>üí° When to Use InheritedWidget?</h4>
                <ul>
                    <li><strong>Theme data:</strong> Colors, fonts, styles app-wide</li>
                    <li><strong>User authentication:</strong> Current user info accessible everywhere</li>
                    <li><strong>App settings:</strong> Language, dark mode preferences</li>
                    <li><strong>Media queries:</strong> Screen size data (Flutter uses this internally)</li>
                </ul>
                <p>
                    <strong>Don't use for:</strong> Frequently changing data (use Provider/Riverpod instead) or 
                    complex state logic (use Bloc/Redux).
                </p>
            </div>
            
            
            <!-- ========================================== -->
            <!-- LESSON 3.3: ADVANCED STATE MANAGEMENT -->
            <!-- ========================================== -->
            
            <div class="lesson-divider">
                <h2>üöÄ Lesson 3.3: Provider, Bloc & Modern Patterns</h2>
            </div>
            
            <div class="analogy-box">
                <div class="analogy-emoji">üè¶</div>
                <div>
                    <h3>Explain Like You're 5: Bank Account System</h3>
                    <p>
                        Think of advanced state management like a bank! <strong>Provider</strong> is like a bank 
                        teller who gives you your account balance whenever you ask (simple access). 
                        <strong>Bloc</strong> is like an ATM machine - you press buttons (events), it processes 
                        your request, and gives you money (new state). Both keep your money (state) safe and 
                        organized, but work differently!
                    </p>
                </div>
            </div>
            
            <h3>üéØ Provider Pattern</h3>
            
            <p>
                Provider is the recommended state management solution by Flutter team. It's built on top of 
                InheritedWidget but much easier to use.
            </p>
            
            <h4>1Ô∏è‚É£ Setting Up Provider</h4>
            
            <pre><code class="language-dart">// pubspec.yaml
dependencies:
  provider: ^6.0.0

// Create a ChangeNotifier model
class CounterModel extends ChangeNotifier {
  int _count = 0;
  
  int get count => _count; // Getter to access count
  
  void increment() {
    _count++;
    notifyListeners(); // Notify all listeners to rebuild
  }
  
  void reset() {
    _count = 0;
    notifyListeners();
  }
}

// Provide it at the top of widget tree
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (context) => CounterModel(),
      child: MaterialApp(
        home: HomePage(),
      ),
    );
  }
}

// Consume it anywhere below
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Listen to changes (rebuilds when notifyListeners called)
    final counter = context.watch&lt;CounterModel&gt;();
    
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Count: ${counter.count}', style: TextStyle(fontSize: 40)),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: () {
                // Call method without rebuilding this widget
                context.read&lt;CounterModel&gt;().increment();
              },
              child: Text('Increment'),
            ),
          ],
        ),
      ),
    );
  }
}</code></pre>
            
            <h4>2Ô∏è‚É£ Provider Methods</h4>
            
            <table>
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Purpose</th>
                        <th>Rebuilds Widget?</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>context.watch&lt;T&gt;()</code></td>
                        <td>Listen to changes, get value</td>
                        <td>‚úÖ Yes</td>
                    </tr>
                    <tr>
                        <td><code>context.read&lt;T&gt;()</code></td>
                        <td>Get value without listening</td>
                        <td>‚ùå No</td>
                    </tr>
                    <tr>
                        <td><code>context.select&lt;T, R&gt;()</code></td>
                        <td>Listen to specific property only</td>
                        <td>‚úÖ Yes (only when selected property changes)</td>
                    </tr>
                    <tr>
                        <td><code>Consumer&lt;T&gt;</code> widget</td>
                        <td>Rebuild only Consumer part</td>
                        <td>‚úÖ Yes (only Consumer subtree)</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>‚ö° Bloc Pattern</h3>
            
            <p>
                Bloc (Business Logic Component) separates UI from business logic using Streams and Events.
            </p>
            
            <h4>1Ô∏è‚É£ Bloc Architecture</h4>
            
            <pre><code class="language-dart">// pubspec.yaml
dependencies:
  flutter_bloc: ^8.0.0

// Define Events (user actions)
abstract class CounterEvent {}

class IncrementEvent extends CounterEvent {}
class DecrementEvent extends CounterEvent {}

// Define State (UI state)
class CounterState {
  final int count;
  CounterState(this.count);
}

// Create Bloc (processes events ‚Üí emits states)
class CounterBloc extends Bloc&lt;CounterEvent, CounterState&gt; {
  CounterBloc() : super(CounterState(0)) {
    // Handle increment event
    on&lt;IncrementEvent&gt;((event, emit) {
      emit(CounterState(state.count + 1));
    });
    
    // Handle decrement event
    on&lt;DecrementEvent&gt;((event, emit) {
      emit(CounterState(state.count - 1));
    });
  }
}

// Provide Bloc
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => CounterBloc(),
      child: MaterialApp(home: HomePage()),
    );
  }
}

// Use Bloc in UI
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: BlocBuilder&lt;CounterBloc, CounterState&gt;(
        builder: (context, state) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text('Count: ${state.count}', style: TextStyle(fontSize: 40)),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    ElevatedButton(
                      onPressed: () {
                        context.read&lt;CounterBloc&gt;().add(IncrementEvent());
                      },
                      child: Text('+'),
                    ),
                    SizedBox(width: 20),
                    ElevatedButton(
                      onPressed: () {
                        context.read&lt;CounterBloc&gt;().add(DecrementEvent());
                      },
                      child: Text('-'),
                    ),
                  ],
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}</code></pre>
            
            <h3>üìä State Management Comparison</h3>
            
            <table>
                <thead>
                    <tr>
                        <th>Solution</th>
                        <th>Complexity</th>
                        <th>Best For</th>
                        <th>Learning Curve</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>setState()</strong></td>
                        <td>Low</td>
                        <td>Simple widgets, local state</td>
                        <td>Easy</td>
                    </tr>
                    <tr>
                        <td><strong>InheritedWidget</strong></td>
                        <td>Medium</td>
                        <td>Static data sharing, themes</td>
                        <td>Medium</td>
                    </tr>
                    <tr>
                        <td><strong>Provider</strong></td>
                        <td>Medium</td>
                        <td>Most apps, recommended by Flutter</td>
                        <td>Easy-Medium</td>
                    </tr>
                    <tr>
                        <td><strong>Bloc</strong></td>
                        <td>High</td>
                        <td>Large apps, complex logic, testing</td>
                        <td>Hard</td>
                    </tr>
                    <tr>
                        <td><strong>Riverpod</strong></td>
                        <td>Medium-High</td>
                        <td>Modern apps, compile-time safety</td>
                        <td>Medium</td>
                    </tr>
                    <tr>
                        <td><strong>GetX</strong></td>
                        <td>Low</td>
                        <td>Quick development, routing + state</td>
                        <td>Easy</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="tip-box">
                <h4>üí° Choosing State Management</h4>
                <p><strong>Decision Tree:</strong></p>
                <ul>
                    <li>Single screen state? ‚Üí <strong>setState()</strong></li>
                    <li>Small app (5-10 screens)? ‚Üí <strong>Provider</strong></li>
                    <li>Large app with complex logic? ‚Üí <strong>Bloc</strong> or <strong>Riverpod</strong></li>
                    <li>Want rapid development? ‚Üí <strong>GetX</strong></li>
                    <li>Team preference/existing codebase? ‚Üí Use what team knows</li>
                </ul>
            </div>
            
            
            <!-- ========================================== -->
            <!-- INTERVIEW QUESTIONS -->
            <!-- ========================================== -->
            
            <div class="interview-section">
                <h3>üéØ Common Interview Questions - Module 3</h3>
                
                <div class="interview-qa">
                    <div class="question">Q1: What happens when you call setState()?</div>
                    <div class="answer">
                        <strong>A:</strong> setState() does two things: 
                        1) Marks the widget as "dirty" (needs rebuild), 
                        2) Schedules a call to build() method. 
                        Flutter's rendering engine batches these updates and rebuilds the widget tree efficiently. 
                        It only rebuilds the specific widget and its descendants, not the entire screen. 
                        The changes must happen inside setState's callback, or the UI won't update.
                    </div>
                </div>
                
                <div class="interview-qa">
                    <div class="question">Q2: What's the difference between initState() and build() in StatefulWidget?</div>
                    <div class="answer">
                        <strong>A:</strong> initState() is called ONCE when the State object is first created. 
                        Use it for initialization: creating controllers, starting API calls, subscribing to streams. 
                        build() is called EVERY TIME the widget needs to rebuild (after setState, hot reload, 
                        parent rebuild). build() must be pure - no side effects, just return widgets.
                    </div>
                </div>
                
                <div class="interview-qa">
                    <div class="question">Q3: Why is dispose() important?</div>
                    <div class="answer">
                        <strong>A:</strong> dispose() prevents memory leaks. When a StatefulWidget is removed 
                        from the tree, you must clean up resources: dispose TextEditingController, 
                        AnimationController, cancel Timer, close Streams, remove listeners. 
                        Failure to dispose causes memory leaks because these objects continue running even after 
                        widget is destroyed.
                    </div>
                </div>
                
                <div class="interview-qa">
                    <div class="question">Q4: How does InheritedWidget differ from passing data through constructors?</div>
                    <div class="answer">
                        <strong>A:</strong> InheritedWidget allows any descendant widget to access data without 
                        prop drilling (passing through every intermediate widget). With constructors, you must 
                        pass data through every layer (A ‚Üí B ‚Üí C ‚Üí D). InheritedWidget lets D access data directly 
                        from A. It also automatically rebuilds dependents when data changes via updateShouldNotify.
                    </div>
                </div>
                
                <div class="interview-qa">
                    <div class="question">Q5: What's the difference between context.watch, context.read, and context.select in Provider?</div>
                    <div class="answer">
                        <strong>A:</strong>
                        <ul>
                            <li><strong>watch()</strong>: Listens to changes, rebuilds widget when notifyListeners called. Use in build().</li>
                            <li><strong>read()</strong>: Gets value without listening, no rebuilds. Use in callbacks/event handlers.</li>
                            <li><strong>select()</strong>: Listens to specific property only, rebuilds only when that property changes. More efficient than watch().</li>
                        </ul>
                        Example: <code>context.watch&lt;User&gt;()</code> rebuilds on any change, 
                        <code>context.select&lt;User, String&gt;((user) => user.name)</code> rebuilds only when name changes.
                    </div>
                </div>
                
                <div class="interview-qa">
                    <div class="question">Q6: Explain the Bloc pattern flow.</div>
                    <div class="answer">
                        <strong>A:</strong> Bloc uses unidirectional data flow:
                        <ol>
                            <li><strong>UI</strong> dispatches an Event (user clicks button)</li>
                            <li><strong>Bloc</strong> receives event, processes business logic</li>
                            <li><strong>Bloc</strong> emits new State</li>
                            <li><strong>UI</strong> rebuilds based on new state</li>
                        </ol>
                        Benefits: Clear separation of UI and logic, easy testing (test events ‚Üí states), 
                        predictable state changes. Uses Streams internally (reactive programming).
                    </div>
                </div>
                
                <div class="interview-qa">
                    <div class="question">Q7: When should you NOT use setState?</div>
                    <div class="answer">
                        <strong>A:</strong> Don't use setState when:
                        <ul>
                            <li>Changing data shared across many screens (use Provider/Bloc)</li>
                            <li>State is complex with many related variables (use state management)</li>
                            <li>You need to test business logic separately (Bloc provides better testability)</li>
                            <li>Building large-scale apps (setState doesn't scale well)</li>
                        </ul>
                        setState is perfect for simple, local widget state like checkboxes, text fields, animations.
                    </div>
                </div>
                
                <div class="interview-qa">
                    <div class="question">Q8: What is ChangeNotifier and how does it work?</div>
                    <div class="answer">
                        <strong>A:</strong> ChangeNotifier is a class from Flutter that provides change 
                        notification to listeners. When you call notifyListeners(), all registered listeners 
                        (widgets using Provider) rebuild. It's the foundation of Provider pattern.
                        <pre><code>class MyModel extends ChangeNotifier {
  int _value = 0;
  
  void update() {
    _value++;
    notifyListeners(); // Triggers rebuild of all listeners
  }
}</code></pre>
                        Must dispose ChangeNotifier to prevent memory leaks!
                    </div>
                </div>
                
            </div>
            
            
            <!-- ========================================== -->
            <!-- NAVIGATION -->
            <!-- ========================================== -->
            
            <div class="navigation-buttons">
                <a href="course-module2.html" class="nav-button prev">
                    ‚Üê Previous: Module 2
                </a>
                <a href="course-index.html" class="nav-button">
                    üìö Course Home
                </a>
                <a href="course-module4.html" class="nav-button next">
                    Next: Module 4 ‚Üí
                </a>
            </div>
            
        </div>
        
        <footer>
            <p><strong>Module 3 of 8</strong> ‚Ä¢ Flutter Interview Course</p>
            <p>¬© 2025 ‚Ä¢ Crafted with ‚ù§Ô∏è for Flutter Developers</p>
        </footer>
    </div>
</body>
</html>